{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quickstart Guide","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Hello and welcome to the quickstart Guide for Soar, a codebase and library designed by the  2025 Screaming Eagles Programming team. This quickstart, similar to roadrunner, is a full codebase consisting of every single file you need to use a robot or field relative drive and command based autonomous with positional commands working as quickly as possible, using an FTCLib structure. </p> <p>If you'd like to use an existing codebase with this project, check out the Soar Library Guide.</p>"},{"location":"#installation","title":"Installation","text":"<p>Note</p> <p>By default, this project works under the assumption that a team is using a 3 odometry pod setup and  a mecanum drivetrain. While modifications can be made for teams that are using different localization options, it is reccomended that you stick to the above configuration for ease of use.</p> <p>Simply download or clone the Quickstart  and open it an IDE of your choice.  </p> <p>Alternatively, run <code>git clone https://github.com/IanP07/Soar-Quickstart</code> in a terminal window. </p>"},{"location":"#mecanumconfigs-constants","title":"MecanumConfigs Constants","text":"<p>To make sure that this codebase works with every type of robot, some information must be provided in the <code>MecanumDrive</code> and  <code>MecanumConstants</code> files. </p>"},{"location":"#wheel-positions","title":"Wheel Positions","text":"<p>First, open the <code>MecanumConfigs</code> file at the path <code>TeamCode/src/main/java/org/firstinspires/ftc/teamcode/shared/mecanum/MecanumConfigs.java</code></p> <p>At the top of the file you will see: <pre><code>    private Translation2d m_frontLeftPositionMeters = new Translation2d(0.178, 0.168);\n    private Translation2d m_frontRightPositionMeters = new Translation2d(0.178, -0.168);\n    private Translation2d m_backLeftPositionMeters = new Translation2d(-0.178, 0.168);\n    private Translation2d m_backRightPositionMeters = new Translation2d(-0.178, -0.168);\n</code></pre></p> <p>Replace the values above with the correct meter values in (y, x) coordinates.  Measure out from the centerpoint of your robot to calculate,  ensuring your result is in meters.</p> <p></p> <p><code>Note the flipped direction of the robot, and how it will impact the coordinates</code></p>"},{"location":"#empirical-constants","title":"Empirical Constants","text":"<p>You will then need to provide values for: <pre><code> private double m_maxRobotSpeedMps = 2.5;\n private double m_maxRobotRotationRps = 6.28;\n private double m_metersPerTick = 0.00056; \n</code></pre> These are determined through testing. In the <code>current/tuning</code> directory of the quickstart, find <code>forwardDriveTest</code>.  This will run all 4 wheels at 100% power. Make sure that they are named correctly in your driver station  configuration, then hit start and record the time it takes to travel a set distance. Then divide the distance  travelled by total time to get the max robot speed.</p> <p>Do the same for rotation using the <code>rotationalTest</code> located in the same directory. Record the test over a set amount of time and divide the amount of total rotations completed by the time to get the max rotation speed</p> <p>Note</p> <p>These values give you the maximum value you should set for the speed and rotation constants, not necessarily the ideal value. For our 2024-25 season robot, our m_maxRobotSpeedMps value was around 3.2,  however setting it to 2.5 gave our driver much more control and worked better for grabbing and scoring game pieces.</p> <p>The <code>m_metersPerTick</code> value can be easily set through a formula. To set it through a formula, find your odometry pod wheel's resolution and radius in meters via the product page, then use the:</p> <p><code>2pi * radius * resolution = meters per tick</code></p> <p>formula to get your value. </p> <p>Finally, ensure that all of your drive motors are following this naming convention in your driverstation config file:</p> <pre><code>    private String m_frontLeftName = \"fL\";\n    private String m_frontRightName = \"fR\";\n    private String m_backLeftName = \"bL\";\n    private String m_backRightName = \"bR\";\n</code></pre>"},{"location":"#mecanumdrive-constants","title":"MecanumDrive Constants","text":""},{"location":"#odometry-pod-configuration","title":"Odometry Pod Configuration","text":"<p>Next, open the <code>MecanumDrive</code> file, and find: </p> <pre><code>    // Mecanum Constants\n    public double deadWheelRadiusCentimeters = 2.4;\n    public double ticksPerRevolution = 2000.0;\n\n    public double trackWidthCentimeters = 36.3;\n    double perpendicularOffsetCentimeters = 20.32;\n</code></pre> <p>Set <code>deadWheelRadiusCentimeters</code> and <code>ticksPerRevolution</code> as per the product page of your odometry pods that you found earlier. Make sure that your deadwheel radius is in centimeters. </p> <p>Then, measure the distance betewen your parallel odometry pods to find <code>trackWidthCentimeters</code> and the distance from the center point where your parallel odometry pods meet to the center of your perpendicular odometry pod to find <code>perpendicularOffsetCentimeters</code>. All your values should be positive. </p> <p></p>"},{"location":"#assigning-motor-rpm","title":"Assigning Motor RPM","text":"<p>Finally, at the top of the MecanumDrive constructor, find:</p> <pre><code>     m_frontLeft = new MotorEx(hardwareMap, m_mecanumConfigs.getFrontLeftName(), Motor.GoBILDA.RPM_312);\n     m_frontRight = new MotorEx(hardwareMap, m_mecanumConfigs.getFrontRightName(), Motor.GoBILDA.RPM_312);\n     m_backLeft = new MotorEx(hardwareMap, m_mecanumConfigs.getBackLeftName(), Motor.GoBILDA.RPM_312);\n     m_backRight = new MotorEx(hardwareMap, m_mecanumConfigs.getBackRightName(), Motor.GoBILDA.RPM_312);\n</code></pre> <p>and replace <code>Motor.GoBILDA.RPM_312</code> with the RPM of your drive motors. </p>"},{"location":"#tuning-pids","title":"Tuning PIDs","text":""},{"location":"#translation-controller","title":"Translation Controller","text":"<p>To start connect to your robot's WiFi network, then open FTCDashboard via the link <code>192.168.43.1:8080/dash</code> or  <code>192.168.49.1:8080/dash</code> if you use a phone as a robot controller. </p> <p>This will allow you to update the PID values live and see changes immediately without restarting the OpMode, which greatly helps with tuning. </p> <p>Once on FTCDashboard, find the <code>tuning</code> directory and open the <code>TranslationControllerTest</code> file. By default, this will have the robot go 100cm forward when clicking <code>a</code>, and back to the zero position when clicking <code>b</code>.</p> <p>On FTCDashboard, you should see <code>Current Position</code> and <code>Target Position</code> in the telemetry section in the bottom right. You should see the current position moving between about 100 and 0, as you hit the <code>a</code> and <code>b</code> buttons. </p> <p>If your current position is undershooting the target position, try slightly increasing the <code>Translation P</code> value in  FTCDashboard. You'll find it in the top right, under the <code>BaseMecanumParams</code> dropdown. Changing the value and hitting enter will update the value. If you are overshooting, try slightly decreasing the <code>Translation P</code> value. </p> <p>Once you have found the ideal value, go to the <code>MecanumDrive</code> file again, and find the <code>Translation P</code> and  <code>Translation I</code> values, and replace them with the values that you got from FTCDashboard. </p> <p>Note</p> <p>We use a <code>Translation P</code> value and a <code>Translation I</code> value. <code>Translation I</code> adds some extra stopping force to the movement. if you find it's not correcting enough as it reaches the position, try slightly increasing <code>Translation I</code>. If you notice weird jerky movements while the robot reaches a position, slightly decrease <code>Translation I</code>. </p>"},{"location":"#rotation-controller","title":"Rotation Controller","text":"<p>Once you have a reasonably accurate translation controller, open the <code>RotationControllerTest</code> file, and open FTCDashboard. This is similar to the Translation Controller test, but hitting the <code>a</code> and <code>b</code> buttons will rotate the robot between 0 and 180 degrees, instead of moving it. Once again, if your rotation is overshooting reduce <code>Rotation P</code>, if it is  undershooting increase it.</p> <p>Again adjust <code>Rotation I</code> as needed, decreasing if movements are overly jerky at the end,  and increasing if it doesn't have enough \"kick\" or power to go to exactly 180 degrees. Then enter the values you end up with in the <code>MecanumDrive</code> file. </p>"},{"location":"#teleop-features","title":"Teleop Features","text":"<p>Congratulations! Your robot should now be fully tuned. Now we can add functionality. </p>"},{"location":"#commanddrive","title":"CommandDrive","text":"<p>To start, run the <code>CommandDrive</code> file on the robot, and test the Drive.  It should be a fully functional field relative drive. If it is, you can move on. If not, try checking the MecanumConstants  you inputted in the above steps, you may have missed a value or need to refine values. </p>"},{"location":"#commands","title":"Commands","text":"<p>Open the <code>CommandDriveAndArm2025</code> file. This file is similar to the <code>CommandDrive</code> file, but adds in commands that the driver and operator can press to call. </p> <pre><code>// Driver Commands\nm_driver.buttonA().whenPressed(new InstantCommand(() -&gt; m_mecanumDrive.resetHeading()));\n\n// Operator Commands\nm_operator.buttonA().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_COLLECT));\nm_operator.buttonB().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_CLEAR_BARRIER));\nm_operator.buttonX().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_SCORE_SAMPLE_IN_LOW));\n\nm_driver.leftBumper().whenPressed((new IntakeCommand(armSubsystem, IntakeCommand.IntakeSetting.INTAKE_COLLECT)));\nm_driver.rightBumper().whenPressed(new IntakeCommand(armSubsystem, IntakeCommand.IntakeSetting.INTAKE_DEPSOSIT));\n\nm_operator.dpadUp().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_SCORE_SPECIMEN));\nm_operator.dpadDown().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_COLLAPSED_INTO_ROBOT));\nm_operator.buttonY().whenPressed(new IntakeCommand(armSubsystem, IntakeCommand.IntakeSetting.INTAKE_OFF));\n\nm_operator.leftBumper().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.LEFT_BUMPER_PRESSED, m_operator));\nm_operator.rightBumper().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.RIGHT_BUMPER_PRESSED, m_operator));\n</code></pre> <p>These Commands are located in 3 files, <code>ArmCommand</code>, <code>WristCommand</code>, and <code>IntakeCommand</code>. We have left in all the commands used in the 2024-25 season, as they may be able to be reused in future seasons, but it is  easy to create and use new custom commands for each season. </p>"},{"location":"#adding-custom-commands","title":"Adding Custom Commands","text":"<p>Our commands follow a:</p> opmode -&gt; command -&gt; subsystem <p>pipeline. The opmode calls a command, which then calls a function to be executed in the subsystem. We do actions in subsystems for better abstraction, and because the subsystems already have access to all the hardware on the robot. It reduces the amount of code we have to write.</p>"},{"location":"#example-of-full-arm-command-structure","title":"Example of full Arm Command Structure:","text":"<p>OpMode: <pre><code>m_operator.buttonX().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_SCORE_SAMPLE_IN_LOW));\n</code></pre></p> <p>This calls the command <code>ArmCommand</code>, the second layer in the opmode -&gt; command -&gt; subsytem process.</p> <p>ArmCommand: <pre><code>case ARM_SCORE_SAMPLE_IN_LOW:\n    m_armSubsystem.setArmPosition(m_armSubsystem.getARM_SCORE_SAMPLE_IN_LOW());\n    m_armSubsystem.setWristPosition(m_armSubsystem.getWRIST_FOLDED_OUT());\n    break;\n</code></pre></p> <p>This is just one part of <code>ArmCommand</code>, set by a switch statement with the case passed in above in the OpMode. This now calls two functions in <code>m_armSubsystem</code>, <code>setArmPosition</code> and <code>setWristPosition</code>. </p> <p>ArmSubsystem functions:</p> <pre><code>public void setWristPosition(double wristPosition) {\n    wrist.setPosition(wristPosition);\n}\n\n...\n\npublic void setArmPosition(double armPosition) {\narmMotor.setTargetPosition((int) (armPosition));\n\n((DcMotorEx) armMotor).setVelocity(2100);\narmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n    }\n</code></pre> <p>Note</p> <p>These functions are the final layer in this process, and actually set the motor speeds. It's useful to seperate things in this way, as it allows you to call commands in parallel, organize things better, and avoid writing redundant code. The motor objects now do not have to be seperately defined within the commands, only the sbusystems, the commands simply call the subsystem functions. </p>"},{"location":"#autonomous-features","title":"Autonomous Features","text":"<p>Soar's autonomous allows you to call <code>DriveToPosition</code> commands. These commands will drive to a given position on a coordinate plane, relative to a starting position (in coordinates), that you pass into the autonomous. </p> <p>Our coordinate plane is in <code>cm</code>, with a center point (0, 0), directly in the middle. The width of the field is 365.76cm, meaning the radius of the field is 182.88cm. Positive rotation is  counterclockwise, with 0 and 360 degrees being in the direction of the Positive X arrow. </p> <p></p> <p>We have also made a website (which will be updated every year), showcasing the coordinate system which adjusts coordinates based on where you move your mouse. This can be useful in determining your autonomous pathing. </p> <p>Coordinate Website </p>"},{"location":"#example-autonomous-program","title":"Example Autonomous Program:","text":"<p>Under the <code>Autos</code> folder in teamcode, open the <code>BlueSampleAuto</code> file. If you want to make your own autonomous programs, copy the file, and change this line:</p> <pre><code> m_mecanumDrive = new Mecanum2025(hardwareMap, mecanumConfigs, new Pose2d(76.6, 159.3, Rotation2d.fromDegrees(270)), BaseMecanumDrive.Alliance.BLUE); // y was 159.3\n</code></pre> <p>And change the <code>Pose2d</code> to the coordinates where your robot will start in the autonomous program, using the coordinate website or measuring yourself from <code>(0, 0)</code>. </p> <p>Then this line:</p> <pre><code>        CommandScheduler.getInstance().schedule(  new BlueSampleCommandRunner(m_mecanumDrive, m_armSubsystem, m_liftSubsystem));\n</code></pre> <p>calls the command <code>BlueSampleCommandRunner</code>. Opening this file which is in the <code>Commands</code> folder, we see:</p> <p>an <code>addCommands()</code> line, with many commands in it. </p> <p>This is the general format of how to write an autonomous with driveToPosition commands. </p> <p><pre><code>new DriveToPosition(m_mecanumDrive, new Pose2d(110, 115, Rotation2d.fromDegrees(215))).withTimeout(200),\n</code></pre> This will drive to the coordinate 110, 115, with a rotation of 215 degrees. Notice the <code>withTimeout(200)</code> at the end. This marks when to cancel the command, in milliseconds.</p> <p>You can also run commands in parallel, using this syntax:</p> <pre><code>new ParallelCommandGroup(\n    new ArmCommand(m_armSubsystem, ArmCommand.ArmPosition.ARM_SCORE_SAMPLE_IN_LOW).withTimeout(1500),\n    new DriveToPosition(m_mecanumDrive, new Pose2d(124, 124, Rotation2d.fromDegrees(217))).withTimeout(2700)\n),\n</code></pre> <p>This runs both the <code>ArmCommand</code> and <code>DriveToPosition</code> command, and they each end when their respective timeOut is called. You can use this simple structure to easily create advanced autonomous programs. It allows for easy duplication of commands, and is more robust than simply driving a direction for a set amount of time, as this now automatically has error control. </p>"},{"location":"#teleop-commands","title":"Teleop Commands","text":"<p>Similarly, you can add commands to your teleop program, accessable by a button press on a controller. You would simply call the commands in your opmode, with the following syntax:</p> <p>CommandDriveAndArm2025:</p> <pre><code>  // Driver Commands\n  m_driver.buttonA().whenPressed(new InstantCommand(() -&gt; m_mecanumDrive.resetHeading()));\n\n\n  // Operator Commands\n  m_operator.buttonA().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_COLLECT));\n  m_operator.buttonB().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_CLEAR_BARRIER));\n  m_operator.buttonX().whenPressed(new ArmCommand(armSubsystem, liftSubsystem, ArmCommand.ArmPosition.ARM_SCORE_SAMPLE_IN_LOW));\n</code></pre> <p>Note</p> <p>You should keep the Driver <code>resetHeading()</code> command, as that when pressed will reset the \"forward\" direction to wherever the robot is looking when pressed. This ensures the robot heading won't drift over time, and makes testing easier. </p>"},{"location":"#end","title":"End","text":"<p>Congratulations! You should now have a working field relative drive, Autonomous <code>DriveToPosition</code> commands through a coordinate system, and the ability to create custom commands for both autonomous and teleop. </p>"},{"location":"LibraryGuide/","title":"Soar Library","text":""},{"location":"LibraryGuide/#under-development","title":"Under Development","text":"<p>The Soar Library is still under development. For now, use the quickstart.</p>"}]}